---
layout: post
title: "vue笔记"
subtitle: “官网基础知识点复习笔记”
date: 2020-08-16 19:10
author: "mipaifu328"
header-img: "img/in-post/2019-03/sea.jpeg"
tag: 
    - vue
---

1. `不要在选项 property 或回调上使用箭头函数`，比如 created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。

2. `created后，data和methods才初始化；mounted后， $el元素才挂在到页面，可以访问。`

3. methods，computed，watch使用场景
  - methods：每当触发重新渲染时，调用方法将`总会再次执行函数`。
  - computed：计算属性是基于它们的`响应式依赖进行缓存`的。只在相关响应式依赖发生改变时它们才会重新求值。
  - watch：当需要在数据变化时`执行异步或开销较大的操作`时，这个方式是最有用的。

4. 数组方法触发更新视图：`push()，pop()，shift()，unshift()，splice()，sort()，reverse()`不更新视图的：`filter()、concat() 和 slice()`。它们不会变更原始数组，而总是返回一个新数组
5. `.sync` 双向绑定，子组件修改父组件传过来的props [详情](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6)

``` js
  // info.vue 子组件
  methods: {
    onInput(e) {
      this.$emit("update:value", e.target.value)    
    } 
  } 
```

``` html
  <!-- index.vue 父组件 -->
  <info :value.sync="myValue"></info>
```

6. 子组件想修改props的2种常见情景 
  - 这个prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 `data` property 并将这个 prop 用作其初始值。
  - 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个`计算属性`.
7. 将原生事件绑定到组件`.native `元素刚好为根元素。如果遇到`非根元素`则可以使用`$listeners` [详情](https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6)
8. 卡槽 [详情](https://cn.vuejs.org/v2/guide/components-slots.html)
- 后备内容 

``` html
  <button type="submit">
    <slot>Submit</slot>
  </button>

  <submit-button></submit-button>
  <!-- 后备内容“Submit”将会被渲染 -->
  <button type="submit">
    Submit
  </button>

  <submit-button>Save</submit-button>
  <!-- 后备内容“Submit”将会被渲染 -->
  <button type="submit">
    Save
  </button>

```

- 作用域

``` html
<navigation-link url="/profile">
  Clicking here will send you to: {{ url }}
  <!--
  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是
  _传递给_ <navigation-link> 的而不是
  在 <navigation-link> 组件*内部*定义的。
  -->
</navigation-link>

<!-- 作用域插槽 -->
<!-- 子组件 -->
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>

<!-- 父组件 -->
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>

<!-- 独占默认插槽可以简写 -->
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
</current-user>

```

>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。
